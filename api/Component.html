---
layout: default
title: "Component API"
categories:
  - api
---
  <div class="row-fluid">
    <div class="page-title documentation-page-title">
      <div class="container">
        <h1 class="page-title__title">API Documentation</h1>
        <a href="https://github.com/noflo/noflo/blob/master/src/lib/Component.coffee" class="btn btn-primary page-title__button big-button">On GitHub</a>
      </div>
    </div>
  </div>

  <div class="row-fluid">
    <div class="container documentation-main-container">
      <div class="main">
        <div class="sidebar span4">
        
          <nav>
            <ul class="sidebar__nav">
              
                
                
                <li>
                  <a {% if page.url == '/api/AsCallback/index.html' %}class="active" {% endif %}href="/api/AsCallback/">
                    AsCallback
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/BasePort/index.html' %}class="active" {% endif %}href="/api/BasePort/">
                    BasePort
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/Component/index.html' %}class="active" {% endif %}href="/api/Component/">
                    Component
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/ComponentLoader/index.html' %}class="active" {% endif %}href="/api/ComponentLoader/">
                    ComponentLoader
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/Helpers/index.html' %}class="active" {% endif %}href="/api/Helpers/">
                    Helpers
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/IP/index.html' %}class="active" {% endif %}href="/api/IP/">
                    IP
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/InPort/index.html' %}class="active" {% endif %}href="/api/InPort/">
                    InPort
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/InternalSocket/index.html' %}class="active" {% endif %}href="/api/InternalSocket/">
                    InternalSocket
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/Network/index.html' %}class="active" {% endif %}href="/api/Network/">
                    Network
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/NoFlo/index.html' %}class="active" {% endif %}href="/api/NoFlo/">
                    NoFlo
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/OutPort/index.html' %}class="active" {% endif %}href="/api/OutPort/">
                    OutPort
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/Platform/index.html' %}class="active" {% endif %}href="/api/Platform/">
                    Platform
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/Ports/index.html' %}class="active" {% endif %}href="/api/Ports/">
                    Ports
                  </a>
                </li>
                
              
                
                
                <li>
                  <a {% if page.url == '/api/Utils/index.html' %}class="active" {% endif %}href="/api/Utils/">
                    Utils
                  </a>
                </li>
                
              
            </ul>
          </nav>
        
        </div>
        <div class="content span8">
          <h1>{{ page.title }}</h1>
          
            
            <pre><code>NoFlo - Flow-Based Programming <span class="hljs-keyword">for</span> JavaScript
(c) <span class="hljs-number">2013</span><span class="hljs-number">-2017</span> Flowhub UG
(c) <span class="hljs-number">2011</span><span class="hljs-number">-2012</span> Henri Bergius, Nemein
NoFlo may be freely distributed under the MIT license
</code></pre>
            
          
            
            <p>Baseclass for regular NoFlo components.</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">var</span> Component, EventEmitter, IP, ProcessContext, ProcessInput, ProcessOutput, debug, debugBrackets, debugSend, ports,
  boundMethodCheck = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">instance, Constructor</span>) </span>{ <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> Constructor)) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Bound instance method accessed before binding'</span>); } };

({EventEmitter} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>));

ports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./Ports'</span>);

IP = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./IP'</span>);

debug = <span class="hljs-built_in">require</span>(<span class="hljs-string">'debug'</span>)(<span class="hljs-string">'noflo:component'</span>);

debugBrackets = <span class="hljs-built_in">require</span>(<span class="hljs-string">'debug'</span>)(<span class="hljs-string">'noflo:component:brackets'</span>);

debugSend = <span class="hljs-built_in">require</span>(<span class="hljs-string">'debug'</span>)(<span class="hljs-string">'noflo:component:send'</span>);

Component = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span> </span>{
    <span class="hljs-keyword">constructor</span>(options) {
      <span class="hljs-keyword">var</span> ref, ref1, ref2;
      <span class="hljs-keyword">super</span>();
      <span class="hljs-keyword">this</span>.error = <span class="hljs-keyword">this</span>.error.bind(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">if</span> (!options) {
        options = {};
      }
      <span class="hljs-keyword">if</span> (!options.inPorts) {
        options.inPorts = {};
      }
      <span class="hljs-keyword">if</span> (options.inPorts <span class="hljs-keyword">instanceof</span> ports.InPorts) {
        <span class="hljs-keyword">this</span>.inPorts = options.inPorts;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.inPorts = <span class="hljs-keyword">new</span> ports.InPorts(options.inPorts);
      }
      <span class="hljs-keyword">if</span> (!options.outPorts) {
        options.outPorts = {};
      }
      <span class="hljs-keyword">if</span> (options.outPorts <span class="hljs-keyword">instanceof</span> ports.OutPorts) {
        <span class="hljs-keyword">this</span>.outPorts = options.outPorts;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.outPorts = <span class="hljs-keyword">new</span> ports.OutPorts(options.outPorts);
      }
      <span class="hljs-keyword">if</span> (options.icon) {
        <span class="hljs-keyword">this</span>.icon = options.icon;
      }
      <span class="hljs-keyword">if</span> (options.description) {
        <span class="hljs-keyword">this</span>.description = options.description;
      }
      <span class="hljs-keyword">this</span>.started = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">this</span>.load = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">this</span>.ordered = (ref = options.ordered) != <span class="hljs-literal">null</span> ? ref : <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">this</span>.autoOrdering = (ref1 = options.autoOrdering) != <span class="hljs-literal">null</span> ? ref1 : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.outputQ = [];
      <span class="hljs-keyword">this</span>.bracketContext = {
        <span class="hljs-attr">in</span>: {},
        <span class="hljs-attr">out</span>: {}
      };
      <span class="hljs-keyword">this</span>.activateOnInput = (ref2 = options.activateOnInput) != <span class="hljs-literal">null</span> ? ref2 : <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">this</span>.forwardBrackets = {
        <span class="hljs-attr">in</span>: [<span class="hljs-string">'out'</span>, <span class="hljs-string">'error'</span>]
      };
      <span class="hljs-keyword">if</span> (<span class="hljs-string">'forwardBrackets'</span> <span class="hljs-keyword">in</span> options) {
        <span class="hljs-keyword">this</span>.forwardBrackets = options.forwardBrackets;
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options.process === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">this</span>.process(options.process);
      }
    }

    getDescription() {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.description;
    }

    isReady() {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    isSubgraph() {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    setIcon(icon) {
      <span class="hljs-keyword">this</span>.icon = icon;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'icon'</span>, <span class="hljs-keyword">this</span>.icon);
    }

    getIcon() {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.icon;
    }

    error(e, groups = [], errorPort = <span class="hljs-string">'error'</span>, scope = <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> group, i, j, len1, len2;
      boundMethodCheck(<span class="hljs-keyword">this</span>, Component);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.outPorts[errorPort] &amp;&amp; (<span class="hljs-keyword">this</span>.outPorts[errorPort].isAttached() || !<span class="hljs-keyword">this</span>.outPorts[errorPort].isRequired())) {
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = groups.length; i &lt; len1; i++) {
          group = groups[i];
          <span class="hljs-keyword">this</span>.outPorts[errorPort].openBracket(group, {
            <span class="hljs-attr">scope</span>: scope
          });
        }
        <span class="hljs-keyword">this</span>.outPorts[errorPort].data(e, {
          <span class="hljs-attr">scope</span>: scope
        });
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>, len2 = groups.length; j &lt; len2; j++) {
          group = groups[j];
          <span class="hljs-keyword">this</span>.outPorts[errorPort].closeBracket(group, {
            <span class="hljs-attr">scope</span>: scope
          });
        }
        <span class="hljs-keyword">return</span>;
      }</pre></div>
            
          
            
            <p>@outPorts[errorPort].disconnect()</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">throw</span> e;
    }</pre></div>
            
          
            
            <p>The setUp method is for component-specific initialization. Called
at start-up</p>

            
              <div class='highlight'><pre>    setUp(callback) {
      callback();
    }</pre></div>
            
          
            
            <p>The tearDown method is for component-specific cleanup. Called
at shutdown</p>

            
              <div class='highlight'><pre>    tearDown(callback) {
      callback();
    }

    start(callback) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isStarted()) {
        <span class="hljs-keyword">return</span> callback();
      }
      <span class="hljs-keyword">this</span>.setUp(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-keyword">return</span> callback(err);
        }
        <span class="hljs-keyword">this</span>.started = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'start'</span>);
        callback(<span class="hljs-literal">null</span>);
      });
    }

    shutdown(callback) {
      <span class="hljs-keyword">var</span> finalize;
      finalize = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">var</span> inPort, inPorts, portName;</pre></div>
            
          
            
            <p>Clear contents of inport buffers</p>

            
              <div class='highlight'><pre>        inPorts = <span class="hljs-keyword">this</span>.inPorts.ports || <span class="hljs-keyword">this</span>.inPorts;
        <span class="hljs-keyword">for</span> (portName <span class="hljs-keyword">in</span> inPorts) {
          inPort = inPorts[portName];
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> inPort.clear !== <span class="hljs-string">'function'</span>) {
            <span class="hljs-keyword">continue</span>;
          }
          inPort.clear();
        }</pre></div>
            
          
            
            <p>Clear bracket context</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">this</span>.bracketContext = {
          <span class="hljs-attr">in</span>: {},
          <span class="hljs-attr">out</span>: {}
        };
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isStarted()) {
          <span class="hljs-keyword">return</span> callback();
        }
        <span class="hljs-keyword">this</span>.started = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'end'</span>);
        callback();
      };</pre></div>
            
          
            
            <p>Tell the component that it is time to shut down</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.tearDown(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
        <span class="hljs-keyword">var</span> checkLoad;
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-keyword">return</span> callback(err);
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.load &gt; <span class="hljs-number">0</span>) {</pre></div>
            
          
            
            <p>Some in-flight processes, wait for them to finish</p>

            
              <div class='highlight'><pre>          checkLoad = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">load</span>) </span>{
            <span class="hljs-keyword">if</span> (load &gt; <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">this</span>.removeListener(<span class="hljs-string">'deactivate'</span>, checkLoad);
            finalize();
          };
          <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'deactivate'</span>, checkLoad);
          <span class="hljs-keyword">return</span>;
        }
        finalize();
      });
    }

    isStarted() {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.started;
    }</pre></div>
            
          
            
            <p>Ensures braket forwarding map is correct for the existing ports</p>

            
              <div class='highlight'><pre>    prepareForwarding() {
      <span class="hljs-keyword">var</span> i, inPort, len1, outPort, outPorts, ref, results, tmp;
      ref = <span class="hljs-keyword">this</span>.forwardBrackets;
      results = [];
      <span class="hljs-keyword">for</span> (inPort <span class="hljs-keyword">in</span> ref) {
        outPorts = ref[inPort];
        <span class="hljs-keyword">if</span> (!(inPort <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.inPorts.ports)) {
          <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.forwardBrackets[inPort];
          <span class="hljs-keyword">continue</span>;
        }
        tmp = [];
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = outPorts.length; i &lt; len1; i++) {
          outPort = outPorts[i];
          <span class="hljs-keyword">if</span> (outPort <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.outPorts.ports) {
            tmp.push(outPort);
          }
        }
        <span class="hljs-keyword">if</span> (tmp.length === <span class="hljs-number">0</span>) {
          results.push(<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.forwardBrackets[inPort]);
        } <span class="hljs-keyword">else</span> {
          results.push(<span class="hljs-keyword">this</span>.forwardBrackets[inPort] = tmp);
        }
      }
      <span class="hljs-keyword">return</span> results;
    }

    isLegacy() {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.handle) {</pre></div>
            
          
            
            <p>Process API</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }</pre></div>
            
          
            
            <p>Legacy</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }</pre></div>
            
          
            
            <p>Sets process handler function</p>

            
              <div class='highlight'><pre>    process(handle) {
      <span class="hljs-keyword">var</span> fn, name, port, ref;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handle !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Process handler must be a function"</span>);
      }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.inPorts) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Component ports must be defined before process function"</span>);
      }
      <span class="hljs-keyword">this</span>.prepareForwarding();
      <span class="hljs-keyword">this</span>.handle = handle;
      ref = <span class="hljs-keyword">this</span>.inPorts.ports;
      fn = <span class="hljs-function">(<span class="hljs-params">name, port</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (!port.name) {
          port.name = name;
        }
        <span class="hljs-keyword">return</span> port.on(<span class="hljs-string">'ip'</span>, (ip) =&gt; {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.handleIP(ip, port);
        });
      };
      <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> ref) {
        port = ref[name];
        fn(name, port);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    isForwardingInport(port) {
      <span class="hljs-keyword">var</span> portName;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> port === <span class="hljs-string">'string'</span>) {
        portName = port;
      } <span class="hljs-keyword">else</span> {
        portName = port.name;
      }
      <span class="hljs-keyword">if</span> (portName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.forwardBrackets) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    isForwardingOutport(inport, outport) {
      <span class="hljs-keyword">var</span> inportName, outportName;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> inport === <span class="hljs-string">'string'</span>) {
        inportName = inport;
      } <span class="hljs-keyword">else</span> {
        inportName = inport.name;
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> outport === <span class="hljs-string">'string'</span>) {
        outportName = outport;
      } <span class="hljs-keyword">else</span> {
        outportName = outport.name;
      }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.forwardBrackets[inportName]) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.forwardBrackets[inportName].indexOf(outportName) !== <span class="hljs-number">-1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    isOrdered() {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ordered) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.autoOrdering) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }</pre></div>
            
          
            
            <p>The component has received an Information Packet. Call the processing function
so that firing pattern preconditions can be checked and component can do
processing as needed.</p>

            
              <div class='highlight'><pre>    handleIP(ip, port) {
      <span class="hljs-keyword">var</span> buf, context, dataPackets, e, input, output, result;
      <span class="hljs-keyword">if</span> (!port.options.triggering) {
        <span class="hljs-keyword">return</span>;
      }</pre></div>
            
          
            
            <p>If port is non-triggering, we can skip the process function call</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'openBracket'</span> &amp;&amp; <span class="hljs-keyword">this</span>.autoOrdering === <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.ordered) {</pre></div>
            
          
            
            <p>Switch component to ordered mode when receiving a stream unless
auto-ordering is disabled</p>

            
              <div class='highlight'><pre>        debug(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> port '<span class="hljs-subst">${port.name}</span>' entered auto-ordering mode`</span>);
        <span class="hljs-keyword">this</span>.autoOrdering = <span class="hljs-literal">true</span>;
      }</pre></div>
            
          
            
            <p>Initialize the result object for situations where output needs
to be queued to be kept in order</p>

            
              <div class='highlight'><pre>      result = {};
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isForwardingInport(port)) {</pre></div>
            
          
            
            <p>For bracket-forwarding inports we need to initialize a bracket context
so that brackets can be sent as part of the output, and closed after.</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'openBracket'</span>) {
          <span class="hljs-keyword">return</span>;
        }</pre></div>
            
          
            
            <p>For forwarding ports openBrackets don’t fire</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'closeBracket'</span>) {</pre></div>
            
          
            
            <p>For forwarding ports closeBrackets don’t fire
However, we need to handle several different scenarios:
A. There are closeBrackets in queue before current packet
B. There are closeBrackets in queue after current packet
C. We’ve queued the results from all in-flight processes and
   new closeBracket arrives</p>

            
              <div class='highlight'><pre>          buf = port.getBuffer(ip.scope, ip.index);
          dataPackets = buf.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ip</span>) </span>{
            <span class="hljs-keyword">return</span> ip.type === <span class="hljs-string">'data'</span>;
          });
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.outputQ.length &gt;= <span class="hljs-keyword">this</span>.load &amp;&amp; dataPackets.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] !== ip) {
              <span class="hljs-keyword">return</span>;
            }</pre></div>
            
          
            
            <p>Remove from buffer</p>

            
              <div class='highlight'><pre>            port.get(ip.scope, ip.index);
            context = <span class="hljs-keyword">this</span>.getBracketContext(<span class="hljs-string">'in'</span>, port.name, ip.scope, ip.index).pop();
            context.closeIp = ip;
            debugBrackets(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> closeBracket-C from '<span class="hljs-subst">${context.source}</span>' to <span class="hljs-subst">${context.ports}</span>: '<span class="hljs-subst">${ip.data}</span>'`</span>);
            result = {
              <span class="hljs-attr">__resolved</span>: <span class="hljs-literal">true</span>,
              <span class="hljs-attr">__bracketClosingAfter</span>: [context]
            };
            <span class="hljs-keyword">this</span>.outputQ.push(result);
            <span class="hljs-keyword">this</span>.processOutputQueue();
          }</pre></div>
            
          
            
            <p>Check if buffer contains data IPs. If it does, we want to allow
firing</p>

            
              <div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!dataPackets.length) {
            <span class="hljs-keyword">return</span>;
          }
        }
      }</pre></div>
            
          
            
            <p>Prepare the input/output pair</p>

            
              <div class='highlight'><pre>      context = <span class="hljs-keyword">new</span> ProcessContext(ip, <span class="hljs-keyword">this</span>, port, result);
      input = <span class="hljs-keyword">new</span> ProcessInput(<span class="hljs-keyword">this</span>.inPorts, context);
      output = <span class="hljs-keyword">new</span> ProcessOutput(<span class="hljs-keyword">this</span>.outPorts, context);
      <span class="hljs-keyword">try</span> {</pre></div>
            
          
            
            <p>Call the processing function</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">this</span>.handle(input, output, context);
      } <span class="hljs-keyword">catch</span> (error1) {
        e = error1;
        <span class="hljs-keyword">this</span>.deactivate(context);
        output.sendDone(e);
      }
      <span class="hljs-keyword">if</span> (context.activated) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">if</span> (port.isAddressable()) {
        debug(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> packet on '<span class="hljs-subst">${port.name}</span>[<span class="hljs-subst">${ip.index}</span>]' didn't match preconditions: <span class="hljs-subst">${ip.type}</span>`</span>);
        <span class="hljs-keyword">return</span>;
      }
      debug(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> packet on '<span class="hljs-subst">${port.name}</span>' didn't match preconditions: <span class="hljs-subst">${ip.type}</span>`</span>);
    }

    getBracketContext(type, port, scope, idx) {
      <span class="hljs-keyword">var</span> index, name, portsList;
      ({name, index} = ports.normalizePortName(port));
      <span class="hljs-keyword">if</span> (idx != <span class="hljs-literal">null</span>) {
        index = idx;
      }
      portsList = type === <span class="hljs-string">'in'</span> ? <span class="hljs-keyword">this</span>.inPorts : <span class="hljs-keyword">this</span>.outPorts;
      <span class="hljs-keyword">if</span> (portsList[name].isAddressable()) {
        port = <span class="hljs-string">`<span class="hljs-subst">${name}</span>[<span class="hljs-subst">${index}</span>]`</span>;
      }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.bracketContext[type][port]) {</pre></div>
            
          
            
            <p>Ensure we have a bracket context for the current scope</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">this</span>.bracketContext[type][port] = {};
      }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.bracketContext[type][port][scope]) {
        <span class="hljs-keyword">this</span>.bracketContext[type][port][scope] = [];
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bracketContext[type][port][scope];
    }

    addToResult(result, port, ip, before = <span class="hljs-literal">false</span>) {
      <span class="hljs-keyword">var</span> idx, index, method, name;
      ({name, index} = ports.normalizePortName(port));
      method = before ? <span class="hljs-string">'unshift'</span> : <span class="hljs-string">'push'</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.outPorts[name].isAddressable()) {
        idx = index ? <span class="hljs-built_in">parseInt</span>(index) : ip.index;
        <span class="hljs-keyword">if</span> (!result[name]) {
          result[name] = {};
        }
        <span class="hljs-keyword">if</span> (!result[name][idx]) {
          result[name][idx] = [];
        }
        ip.index = idx;
        result[name][idx][method](ip);
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">if</span> (!result[name]) {
        result[name] = [];
      }
      <span class="hljs-keyword">return</span> result[name][method](ip);
    }

    getForwardableContexts(inport, outport, contexts) {
      <span class="hljs-keyword">var</span> forwardable, index, name;
      ({name, index} = ports.normalizePortName(outport));
      forwardable = [];
      contexts.forEach(<span class="hljs-function">(<span class="hljs-params">ctx, idx</span>) =&gt;</span> {
        <span class="hljs-keyword">var</span> outContext;</pre></div>
            
          
            
            <p>No forwarding to this outport</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isForwardingOutport(inport, name)) {
          <span class="hljs-keyword">return</span>;
        }</pre></div>
            
          
            
            <p>We have already forwarded this context to this outport</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (ctx.ports.indexOf(outport) !== <span class="hljs-number">-1</span>) {
          <span class="hljs-keyword">return</span>;
        }</pre></div>
            
          
            
            <p>See if we have already forwarded the same bracket from another
inport</p>

            
              <div class='highlight'><pre>        outContext = <span class="hljs-keyword">this</span>.getBracketContext(<span class="hljs-string">'out'</span>, name, ctx.ip.scope, index)[idx];
        <span class="hljs-keyword">if</span> (outContext) {
          <span class="hljs-keyword">if</span> (outContext.ip.data === ctx.ip.data &amp;&amp; outContext.ports.indexOf(outport) !== <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">return</span>;
          }
        }
        <span class="hljs-keyword">return</span> forwardable.push(ctx);
      });
      <span class="hljs-keyword">return</span> forwardable;
    }

    addBracketForwards(result) {
      <span class="hljs-keyword">var</span> context, i, ipClone, j, k, l, len1, len2, len3, len4, port, ref, ref1, ref2, ref3, ref4, ref5;
      <span class="hljs-keyword">if</span> ((ref = result.__bracketClosingBefore) != <span class="hljs-literal">null</span> ? ref.length : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) {
        ref1 = result.__bracketClosingBefore;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = ref1.length; i &lt; len1; i++) {
          context = ref1[i];
          debugBrackets(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> closeBracket-A from '<span class="hljs-subst">${context.source}</span>' to <span class="hljs-subst">${context.ports}</span>: '<span class="hljs-subst">${context.closeIp.data}</span>'`</span>);
          <span class="hljs-keyword">if</span> (!context.ports.length) {
            <span class="hljs-keyword">continue</span>;
          }
          ref2 = context.ports;
          <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>, len2 = ref2.length; j &lt; len2; j++) {
            port = ref2[j];
            ipClone = context.closeIp.clone();
            <span class="hljs-keyword">this</span>.addToResult(result, port, ipClone, <span class="hljs-literal">true</span>);
            <span class="hljs-keyword">this</span>.getBracketContext(<span class="hljs-string">'out'</span>, port, ipClone.scope).pop();
          }
        }
      }
      <span class="hljs-keyword">if</span> (result.__bracketContext) {</pre></div>
            
          
            
            <p>First see if there are any brackets to forward. We need to reverse
the keys so that they get added in correct order</p>

            
              <div class='highlight'><pre>        <span class="hljs-built_in">Object</span>.keys(result.__bracketContext).reverse().forEach(<span class="hljs-function">(<span class="hljs-params">inport</span>) =&gt;</span> {
          <span class="hljs-keyword">var</span> ctx, datas, forwardedOpens, idx, idxIps, ip, ips, k, l, len3, len4, len5, m, outport, portIdentifier, results, unforwarded;
          context = result.__bracketContext[inport];
          <span class="hljs-keyword">if</span> (!context.length) {
            <span class="hljs-keyword">return</span>;
          }
          results = [];
          <span class="hljs-keyword">for</span> (outport <span class="hljs-keyword">in</span> result) {
            ips = result[outport];
            <span class="hljs-keyword">if</span> (outport.indexOf(<span class="hljs-string">'__'</span>) === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.outPorts[outport].isAddressable()) {
              <span class="hljs-keyword">for</span> (idx <span class="hljs-keyword">in</span> ips) {
                idxIps = ips[idx];</pre></div>
            
          
            
            <p>Don’t register indexes we’re only sending brackets to</p>

            
              <div class='highlight'><pre>                datas = idxIps.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ip</span>) </span>{
                  <span class="hljs-keyword">return</span> ip.type === <span class="hljs-string">'data'</span>;
                });
                <span class="hljs-keyword">if</span> (!datas.length) {
                  <span class="hljs-keyword">continue</span>;
                }
                portIdentifier = <span class="hljs-string">`<span class="hljs-subst">${outport}</span>[<span class="hljs-subst">${idx}</span>]`</span>;
                unforwarded = <span class="hljs-keyword">this</span>.getForwardableContexts(inport, portIdentifier, context);
                <span class="hljs-keyword">if</span> (!unforwarded.length) {
                  <span class="hljs-keyword">continue</span>;
                }
                forwardedOpens = [];
                <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>, len3 = unforwarded.length; k &lt; len3; k++) {
                  ctx = unforwarded[k];
                  debugBrackets(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> openBracket from '<span class="hljs-subst">${inport}</span>' to '<span class="hljs-subst">${portIdentifier}</span>': '<span class="hljs-subst">${ctx.ip.data}</span>'`</span>);
                  ipClone = ctx.ip.clone();
                  ipClone.index = <span class="hljs-built_in">parseInt</span>(idx);
                  forwardedOpens.push(ipClone);
                  ctx.ports.push(portIdentifier);
                  <span class="hljs-keyword">this</span>.getBracketContext(<span class="hljs-string">'out'</span>, outport, ctx.ip.scope, idx).push(ctx);
                }
                forwardedOpens.reverse();
                <span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>, len4 = forwardedOpens.length; l &lt; len4; l++) {
                  ip = forwardedOpens[l];
                  <span class="hljs-keyword">this</span>.addToResult(result, outport, ip, <span class="hljs-literal">true</span>);
                }
              }
              <span class="hljs-keyword">continue</span>;
            }</pre></div>
            
          
            
            <p>Don’t register ports we’re only sending brackets to</p>

            
              <div class='highlight'><pre>            datas = ips.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ip</span>) </span>{
              <span class="hljs-keyword">return</span> ip.type === <span class="hljs-string">'data'</span>;
            });
            <span class="hljs-keyword">if</span> (!datas.length) {
              <span class="hljs-keyword">continue</span>;
            }
            unforwarded = <span class="hljs-keyword">this</span>.getForwardableContexts(inport, outport, context);
            <span class="hljs-keyword">if</span> (!unforwarded.length) {
              <span class="hljs-keyword">continue</span>;
            }
            forwardedOpens = [];
            <span class="hljs-keyword">for</span> (m = <span class="hljs-number">0</span>, len5 = unforwarded.length; m &lt; len5; m++) {
              ctx = unforwarded[m];
              debugBrackets(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> openBracket from '<span class="hljs-subst">${inport}</span>' to '<span class="hljs-subst">${outport}</span>': '<span class="hljs-subst">${ctx.ip.data}</span>'`</span>);
              forwardedOpens.push(ctx.ip.clone());
              ctx.ports.push(outport);
              <span class="hljs-keyword">this</span>.getBracketContext(<span class="hljs-string">'out'</span>, outport, ctx.ip.scope).push(ctx);
            }
            forwardedOpens.reverse();
            results.push((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">var</span> len6, n, results1;
              results1 = [];
              <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>, len6 = forwardedOpens.length; n &lt; len6; n++) {
                ip = forwardedOpens[n];
                results1.push(<span class="hljs-keyword">this</span>.addToResult(result, outport, ip, <span class="hljs-literal">true</span>));
              }
              <span class="hljs-keyword">return</span> results1;
            }).call(<span class="hljs-keyword">this</span>));
          }
          <span class="hljs-keyword">return</span> results;
        });
      }
      <span class="hljs-keyword">if</span> ((ref3 = result.__bracketClosingAfter) != <span class="hljs-literal">null</span> ? ref3.length : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) {
        ref4 = result.__bracketClosingAfter;
        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>, len3 = ref4.length; k &lt; len3; k++) {
          context = ref4[k];
          debugBrackets(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> closeBracket-B from '<span class="hljs-subst">${context.source}</span>' to <span class="hljs-subst">${context.ports}</span>: '<span class="hljs-subst">${context.closeIp.data}</span>'`</span>);
          <span class="hljs-keyword">if</span> (!context.ports.length) {
            <span class="hljs-keyword">continue</span>;
          }
          ref5 = context.ports;
          <span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>, len4 = ref5.length; l &lt; len4; l++) {
            port = ref5[l];
            ipClone = context.closeIp.clone();
            <span class="hljs-keyword">this</span>.addToResult(result, port, ipClone, <span class="hljs-literal">false</span>);
            <span class="hljs-keyword">this</span>.getBracketContext(<span class="hljs-string">'out'</span>, port, ipClone.scope).pop();
          }
        }
      }
      <span class="hljs-keyword">delete</span> result.__bracketClosingBefore;
      <span class="hljs-keyword">delete</span> result.__bracketContext;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">delete</span> result.__bracketClosingAfter;
    }

    processOutputQueue() {
      <span class="hljs-keyword">var</span> idx, idxIps, ip, ips, port, portIdentifier, result, results;
      results = [];
      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.outputQ.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.outputQ[<span class="hljs-number">0</span>].__resolved) {
          <span class="hljs-keyword">break</span>;
        }
        result = <span class="hljs-keyword">this</span>.outputQ.shift();
        <span class="hljs-keyword">this</span>.addBracketForwards(result);
        results.push((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> i, len1, results1;
          results1 = [];
          <span class="hljs-keyword">for</span> (port <span class="hljs-keyword">in</span> result) {
            ips = result[port];
            <span class="hljs-keyword">if</span> (port.indexOf(<span class="hljs-string">'__'</span>) === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.outPorts.ports[port].isAddressable()) {
              <span class="hljs-keyword">for</span> (idx <span class="hljs-keyword">in</span> ips) {
                idxIps = ips[idx];
                idx = <span class="hljs-built_in">parseInt</span>(idx);
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.outPorts.ports[port].isAttached(idx)) {
                  <span class="hljs-keyword">continue</span>;
                }
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = idxIps.length; i &lt; len1; i++) {
                  ip = idxIps[i];
                  portIdentifier = <span class="hljs-string">`<span class="hljs-subst">${port}</span>[<span class="hljs-subst">${ip.index}</span>]`</span>;
                  <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'openBracket'</span>) {
                    debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> &lt; '<span class="hljs-subst">${ip.data}</span>'`</span>);
                  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'closeBracket'</span>) {
                    debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> &gt; '<span class="hljs-subst">${ip.data}</span>'`</span>);
                  } <span class="hljs-keyword">else</span> {
                    debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> DATA`</span>);
                  }
                  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.outPorts[port].options.scoped) {
                    ip.scope = <span class="hljs-literal">null</span>;
                  }
                  <span class="hljs-keyword">this</span>.outPorts[port].sendIP(ip);
                }
              }
              <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.outPorts.ports[port].isAttached()) {
              <span class="hljs-keyword">continue</span>;
            }
            results1.push((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">var</span> j, len2, results2;
              results2 = [];
              <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>, len2 = ips.length; j &lt; len2; j++) {
                ip = ips[j];
                portIdentifier = port;
                <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'openBracket'</span>) {
                  debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> &lt; '<span class="hljs-subst">${ip.data}</span>'`</span>);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'closeBracket'</span>) {
                  debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> &gt; '<span class="hljs-subst">${ip.data}</span>'`</span>);
                } <span class="hljs-keyword">else</span> {
                  debugSend(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeId}</span> sending <span class="hljs-subst">${portIdentifier}</span> DATA`</span>);
                }
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.outPorts[port].options.scoped) {
                  ip.scope = <span class="hljs-literal">null</span>;
                }
                results2.push(<span class="hljs-keyword">this</span>.outPorts[port].sendIP(ip));
              }
              <span class="hljs-keyword">return</span> results2;
            }).call(<span class="hljs-keyword">this</span>));
          }
          <span class="hljs-keyword">return</span> results1;
        }).call(<span class="hljs-keyword">this</span>));
      }
      <span class="hljs-keyword">return</span> results;
    }

    activate(context) {
      <span class="hljs-keyword">if</span> (context.activated) { <span class="hljs-comment">// prevent double activation</span>
        <span class="hljs-keyword">return</span>;
      }
      context.activated = <span class="hljs-literal">true</span>;
      context.deactivated = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">this</span>.load++;
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'activate'</span>, <span class="hljs-keyword">this</span>.load);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ordered || <span class="hljs-keyword">this</span>.autoOrdering) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.outputQ.push(context.result);
      }
    }

    deactivate(context) {
      <span class="hljs-keyword">if</span> (context.deactivated) { <span class="hljs-comment">// prevent double deactivation</span>
        <span class="hljs-keyword">return</span>;
      }
      context.deactivated = <span class="hljs-literal">true</span>;
      context.activated = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isOrdered()) {
        <span class="hljs-keyword">this</span>.processOutputQueue();
      }
      <span class="hljs-keyword">this</span>.load--;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'deactivate'</span>, <span class="hljs-keyword">this</span>.load);
    }

  };

  Component.prototype.description = <span class="hljs-string">''</span>;

  Component.prototype.icon = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">return</span> Component;

})();

exports.Component = Component;

ProcessContext = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessContext</span> </span>{
  <span class="hljs-keyword">constructor</span>(ip1, nodeInstance, port1, result1) {
    <span class="hljs-keyword">this</span>.ip = ip1;
    <span class="hljs-keyword">this</span>.nodeInstance = nodeInstance;
    <span class="hljs-keyword">this</span>.port = port1;
    <span class="hljs-keyword">this</span>.result = result1;
    <span class="hljs-keyword">this</span>.scope = <span class="hljs-keyword">this</span>.ip.scope;
    <span class="hljs-keyword">this</span>.activated = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.deactivated = <span class="hljs-literal">false</span>;
  }

  activate() {</pre></div>
            
          
            
            <p>Push a new result value if previous has been sent already</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.result.__resolved || <span class="hljs-keyword">this</span>.nodeInstance.outputQ.indexOf(<span class="hljs-keyword">this</span>.result) === <span class="hljs-number">-1</span>) {
      <span class="hljs-keyword">this</span>.result = {};
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nodeInstance.activate(<span class="hljs-keyword">this</span>);
  }

  deactivate() {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.result.__resolved) {
      <span class="hljs-keyword">this</span>.result.__resolved = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nodeInstance.deactivate(<span class="hljs-keyword">this</span>);
  }

};

ProcessInput = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessInput</span> </span>{
  <span class="hljs-keyword">constructor</span>(ports1, context1) {
    <span class="hljs-keyword">this</span>.ports = ports1;
    <span class="hljs-keyword">this</span>.context = context1;
    <span class="hljs-keyword">this</span>.nodeInstance = <span class="hljs-keyword">this</span>.context.nodeInstance;
    <span class="hljs-keyword">this</span>.ip = <span class="hljs-keyword">this</span>.context.ip;
    <span class="hljs-keyword">this</span>.port = <span class="hljs-keyword">this</span>.context.port;
    <span class="hljs-keyword">this</span>.result = <span class="hljs-keyword">this</span>.context.result;
    <span class="hljs-keyword">this</span>.scope = <span class="hljs-keyword">this</span>.context.scope;
  }</pre></div>
            
          
            
            <p>When preconditions are met, set component state to <code>activated</code></p>

            
              <div class='highlight'><pre>  activate() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.context.activated) {
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nodeInstance.isOrdered()) {</pre></div>
            
          
            
            <p>We’re handling packets in order. Set the result as non-resolved
so that it can be send when the order comes up</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.result.__resolved = <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">this</span>.nodeInstance.activate(<span class="hljs-keyword">this</span>.context);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.port.isAddressable()) {
      <span class="hljs-keyword">return</span> debug(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeInstance.nodeId}</span> packet on '<span class="hljs-subst">${<span class="hljs-keyword">this</span>.port.name}</span>[<span class="hljs-subst">${<span class="hljs-keyword">this</span>.ip.index}</span>]' caused activation <span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeInstance.load}</span>: <span class="hljs-subst">${<span class="hljs-keyword">this</span>.ip.type}</span>`</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> debug(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeInstance.nodeId}</span> packet on '<span class="hljs-subst">${<span class="hljs-keyword">this</span>.port.name}</span>' caused activation <span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeInstance.load}</span>: <span class="hljs-subst">${<span class="hljs-keyword">this</span>.ip.type}</span>`</span>);
    }
  }</pre></div>
            
          
            
            <h2 id="connection-listing">Connection listing</h2>
<p>This allows components to check which input ports are attached. This is
useful mainly for addressable ports</p>

            
              <div class='highlight'><pre>  attached(...args) {
    <span class="hljs-keyword">var</span> i, len1, port, res;
    <span class="hljs-keyword">if</span> (!args.length) {
      args = [<span class="hljs-string">'in'</span>];
    }
    res = [];
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = args.length; i &lt; len1; i++) {
      port = args[i];
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ports[port]) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Node <span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeInstance.nodeId}</span> has no port '<span class="hljs-subst">${port}</span>'`</span>);
      }
      res.push(<span class="hljs-keyword">this</span>.ports[port].listAttached());
    }
    <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> res.pop();
    }
    <span class="hljs-keyword">return</span> res;
  }</pre></div>
            
          
            
            <h2 id="input-preconditions">Input preconditions</h2>
<p>When the processing function is called, it can check if input buffers
contain the packets needed for the process to fire.
This precondition handling is done via the <code>has</code> and <code>hasStream</code> methods.</p>

            
          
            
            <p>Returns true if a port (or ports joined by logical AND) has a new IP
Passing a validation callback as a last argument allows more selective
checking of packets.</p>

            
              <div class='highlight'><pre>  has(...args) {
    <span class="hljs-keyword">var</span> i, len1, port, validate;
    <span class="hljs-keyword">if</span> (!args.length) {
      args = [<span class="hljs-string">'in'</span>];
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args[args.length - <span class="hljs-number">1</span>] === <span class="hljs-string">'function'</span>) {
      validate = args.pop();
    } <span class="hljs-keyword">else</span> {
      validate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      };
    }
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = args.length; i &lt; len1; i++) {
      port = args[i];
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(port)) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ports[port[<span class="hljs-number">0</span>]]) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Node <span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeInstance.nodeId}</span> has no port '<span class="hljs-subst">${port[<span class="hljs-number">0</span>]}</span>'`</span>);
        }
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ports[port[<span class="hljs-number">0</span>]].isAddressable()) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Non-addressable ports, access must be with string <span class="hljs-subst">${port[<span class="hljs-number">0</span>]}</span>`</span>);
        }
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ports[port[<span class="hljs-number">0</span>]].has(<span class="hljs-keyword">this</span>.scope, port[<span class="hljs-number">1</span>], validate)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ports[port]) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Node <span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeInstance.nodeId}</span> has no port '<span class="hljs-subst">${port}</span>'`</span>);
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ports[port].isAddressable()) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`For addressable ports, access must be with array [<span class="hljs-subst">${port}</span>, idx]`</span>);
      }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ports[port].has(<span class="hljs-keyword">this</span>.scope, validate)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }</pre></div>
            
          
            
            <p>Returns true if the ports contain data packets</p>

            
              <div class='highlight'><pre>  hasData(...args) {
    <span class="hljs-keyword">if</span> (!args.length) {
      args = [<span class="hljs-string">'in'</span>];
    }
    args.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ip</span>) </span>{
      <span class="hljs-keyword">return</span> ip.type === <span class="hljs-string">'data'</span>;
    });
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.has.apply(<span class="hljs-keyword">this</span>, args);
  }</pre></div>
            
          
            
            <p>Returns true if a port has a complete stream in its input buffer.</p>

            
              <div class='highlight'><pre>  hasStream(...args) {
    <span class="hljs-keyword">var</span> dataBrackets, hasData, i, len1, port, portBrackets, validate, validateStream;
    <span class="hljs-keyword">if</span> (!args.length) {
      args = [<span class="hljs-string">'in'</span>];
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args[args.length - <span class="hljs-number">1</span>] === <span class="hljs-string">'function'</span>) {
      validateStream = args.pop();
    } <span class="hljs-keyword">else</span> {
      validateStream = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      };
    }
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = args.length; i &lt; len1; i++) {
      port = args[i];
      portBrackets = [];
      dataBrackets = [];
      hasData = <span class="hljs-literal">false</span>;
      validate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ip</span>) </span>{
        <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'openBracket'</span>) {
          portBrackets.push(ip.data);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'data'</span>) {</pre></div>
            
          
            
            <p>Run the stream validation callback</p>

            
              <div class='highlight'><pre>          hasData = validateStream(ip, portBrackets);
          <span class="hljs-keyword">if</span> (!portBrackets.length) {</pre></div>
            
          
            
            <p>Data IP on its own is a valid stream</p>

            
              <div class='highlight'><pre>            <span class="hljs-keyword">return</span> hasData;
          }</pre></div>
            
          
            
            <p>Otherwise we need to check for complete stream</p>

            
              <div class='highlight'><pre>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'closeBracket'</span>) {
          portBrackets.pop();
          <span class="hljs-keyword">if</span> (portBrackets.length) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
          <span class="hljs-keyword">if</span> (!hasData) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      };
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.has(port, validate)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }</pre></div>
            
          
            
            <h2 id="input-processing">Input processing</h2>

            
          
            
            <p>Once preconditions have been met, the processing function can read from
the input buffers. Reading packets sets the component as “activated”.</p>

            
          
            
            <p>Fetches IP object(s) for port(s)</p>

            
              <div class='highlight'><pre>  get(...args) {
    <span class="hljs-keyword">var</span> i, idx, ip, len1, port, portname, res;
    <span class="hljs-keyword">this</span>.activate();
    <span class="hljs-keyword">if</span> (!args.length) {
      args = [<span class="hljs-string">'in'</span>];
    }
    res = [];
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = args.length; i &lt; len1; i++) {
      port = args[i];
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(port)) {
        [portname, idx] = port;
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ports[portname].isAddressable()) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Non-addressable ports, access must be with string portname'</span>);
        }
      } <span class="hljs-keyword">else</span> {
        portname = port;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ports[portname].isAddressable()) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'For addressable ports, access must be with array [portname, idx]'</span>);
        }
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nodeInstance.isForwardingInport(portname)) {
        ip = <span class="hljs-keyword">this</span>.__getForForwarding(portname, idx);
        res.push(ip);
        <span class="hljs-keyword">continue</span>;
      }
      ip = <span class="hljs-keyword">this</span>.ports[portname].get(<span class="hljs-keyword">this</span>.scope, idx);
      res.push(ip);
    }
    <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> res;
    }
  }

  __getForForwarding(port, idx) {
    <span class="hljs-keyword">var</span> context, dataIp, i, ip, len1, prefix;
    prefix = [];
    dataIp = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</pre></div>
            
          
            
            <p>Read next packet
Read IPs until we hit data</p>

            
              <div class='highlight'><pre>      ip = <span class="hljs-keyword">this</span>.ports[port].get(<span class="hljs-keyword">this</span>.scope, idx);
      <span class="hljs-keyword">if</span> (!ip) {</pre></div>
            
          
            
            <p>Stop at the end of the buffer</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'data'</span>) {</pre></div>
            
          
            
            <p>Hit the data IP, stop here</p>

            
              <div class='highlight'><pre>        dataIp = ip;
        <span class="hljs-keyword">break</span>;
      }</pre></div>
            
          
            
            <p>Keep track of bracket closings and openings before</p>

            
              <div class='highlight'><pre>      prefix.push(ip);
    }</pre></div>
            
          
            
            <p>Forwarding brackets that came before data packet need to manipulate context
and be added to result so they can be forwarded correctly to ports that
need them</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = prefix.length; i &lt; len1; i++) {
      ip = prefix[i];
      <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'closeBracket'</span>) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.result.__bracketClosingBefore) {</pre></div>
            
          
            
            <p>Bracket closings before data should remove bracket context</p>

            
              <div class='highlight'><pre>          <span class="hljs-keyword">this</span>.result.__bracketClosingBefore = [];
        }
        context = <span class="hljs-keyword">this</span>.nodeInstance.getBracketContext(<span class="hljs-string">'in'</span>, port, <span class="hljs-keyword">this</span>.scope, idx).pop();
        context.closeIp = ip;
        <span class="hljs-keyword">this</span>.result.__bracketClosingBefore.push(context);
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'openBracket'</span>) {</pre></div>
            
          
            
            <p>Bracket openings need to go to bracket context</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">this</span>.nodeInstance.getBracketContext(<span class="hljs-string">'in'</span>, port, <span class="hljs-keyword">this</span>.scope, idx).push({
          <span class="hljs-attr">ip</span>: ip,
          <span class="hljs-attr">ports</span>: [],
          <span class="hljs-attr">source</span>: port
        });
        <span class="hljs-keyword">continue</span>;
      }
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.result.__bracketContext) {</pre></div>
            
          
            
            <p>Add current bracket context to the result so that when we send
to ports we can also add the surrounding brackets</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.result.__bracketContext = {};
    }
    <span class="hljs-keyword">this</span>.result.__bracketContext[port] = <span class="hljs-keyword">this</span>.nodeInstance.getBracketContext(<span class="hljs-string">'in'</span>, port, <span class="hljs-keyword">this</span>.scope, idx).slice(<span class="hljs-number">0</span>);</pre></div>
            
          
            
            <p>Bracket closings that were in buffer after the data packet need to
be added to result for done() to read them from</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">return</span> dataIp;
  }</pre></div>
            
          
            
            <p>Fetches <code>data</code> property of IP object(s) for given port(s)</p>

            
              <div class='highlight'><pre>  getData(...args) {
    <span class="hljs-keyword">var</span> datas, i, len1, packet, port;
    <span class="hljs-keyword">if</span> (!args.length) {
      args = [<span class="hljs-string">'in'</span>];
    }
    datas = [];
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = args.length; i &lt; len1; i++) {
      port = args[i];
      packet = <span class="hljs-keyword">this</span>.get(port);
      <span class="hljs-keyword">if</span> (packet == <span class="hljs-literal">null</span>) {</pre></div>
            
          
            
            <p>we add the null packet to the array so when getting
multiple ports, if one is null we still return it
so the indexes are correct.</p>

            
              <div class='highlight'><pre>        datas.push(packet);
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">while</span> (packet.type !== <span class="hljs-string">'data'</span>) {
        packet = <span class="hljs-keyword">this</span>.get(port);
        <span class="hljs-keyword">if</span> (!packet) {
          <span class="hljs-keyword">break</span>;
        }
      }
      datas.push(packet.data);
    }
    <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> datas.pop();
    }
    <span class="hljs-keyword">return</span> datas;
  }</pre></div>
            
          
            
            <p>Fetches a complete data stream from the buffer.</p>

            
              <div class='highlight'><pre>  getStream(...args) {
    <span class="hljs-keyword">var</span> datas, hasData, i, ip, len1, port, portBrackets, portPackets;
    <span class="hljs-keyword">if</span> (!args.length) {
      args = [<span class="hljs-string">'in'</span>];
    }
    datas = [];
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = args.length; i &lt; len1; i++) {
      port = args[i];
      portBrackets = [];
      portPackets = [];
      hasData = <span class="hljs-literal">false</span>;
      ip = <span class="hljs-keyword">this</span>.get(port);
      <span class="hljs-keyword">if</span> (!ip) {
        datas.push(<span class="hljs-keyword">void</span> <span class="hljs-number">0</span>);
      }
      <span class="hljs-keyword">while</span> (ip) {
        <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'openBracket'</span>) {
          <span class="hljs-keyword">if</span> (!portBrackets.length) {</pre></div>
            
          
            
            <p>First openBracket in stream, drop previous</p>

            
              <div class='highlight'><pre>            portPackets = [];
            hasData = <span class="hljs-literal">false</span>;
          }
          portBrackets.push(ip.data);
          portPackets.push(ip);
        }
        <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'data'</span>) {
          portPackets.push(ip);
          hasData = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">if</span> (!portBrackets.length) {</pre></div>
            
          
            
            <p>Unbracketed data packet is a valid stream</p>

            
              <div class='highlight'><pre>            <span class="hljs-keyword">break</span>;
          }
        }
        <span class="hljs-keyword">if</span> (ip.type === <span class="hljs-string">'closeBracket'</span>) {
          portPackets.push(ip);
          portBrackets.pop();
          <span class="hljs-keyword">if</span> (hasData &amp;&amp; !portBrackets.length) {</pre></div>
            
          
            
            <p>Last close bracket finishes stream if there was data inside</p>

            
              <div class='highlight'><pre>            <span class="hljs-keyword">break</span>;
          }
        }
        ip = <span class="hljs-keyword">this</span>.get(port);
      }
      datas.push(portPackets);
    }
    <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> datas.pop();
    }
    <span class="hljs-keyword">return</span> datas;
  }

};

ProcessOutput = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessOutput</span> </span>{
  <span class="hljs-keyword">constructor</span>(ports1, context1) {
    <span class="hljs-keyword">this</span>.ports = ports1;
    <span class="hljs-keyword">this</span>.context = context1;
    <span class="hljs-keyword">this</span>.nodeInstance = <span class="hljs-keyword">this</span>.context.nodeInstance;
    <span class="hljs-keyword">this</span>.ip = <span class="hljs-keyword">this</span>.context.ip;
    <span class="hljs-keyword">this</span>.result = <span class="hljs-keyword">this</span>.context.result;
    <span class="hljs-keyword">this</span>.scope = <span class="hljs-keyword">this</span>.context.scope;
  }</pre></div>
            
          
            
            <p>Checks if a value is an Error</p>

            
              <div class='highlight'><pre>  isError(err) {
    <span class="hljs-keyword">return</span> err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> || <span class="hljs-built_in">Array</span>.isArray(err) &amp;&amp; err.length &gt; <span class="hljs-number">0</span> &amp;&amp; err[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>;
  }</pre></div>
            
          
            
            <p>Sends an error object</p>

            
              <div class='highlight'><pre>  error(err) {
    <span class="hljs-keyword">var</span> e, i, j, len1, len2, multiple, results;
    multiple = <span class="hljs-built_in">Array</span>.isArray(err);
    <span class="hljs-keyword">if</span> (!multiple) {
      err = [err];
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'error'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.ports &amp;&amp; (<span class="hljs-keyword">this</span>.ports.error.isAttached() || !<span class="hljs-keyword">this</span>.ports.error.isRequired())) {
      <span class="hljs-keyword">if</span> (multiple) {
        <span class="hljs-keyword">this</span>.sendIP(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> IP(<span class="hljs-string">'openBracket'</span>));
      }
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = err.length; i &lt; len1; i++) {
        e = err[i];
        <span class="hljs-keyword">this</span>.sendIP(<span class="hljs-string">'error'</span>, e);
      }
      <span class="hljs-keyword">if</span> (multiple) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sendIP(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> IP(<span class="hljs-string">'closeBracket'</span>));
      }
    } <span class="hljs-keyword">else</span> {
      results = [];
      <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>, len2 = err.length; j &lt; len2; j++) {
        e = err[j];
        <span class="hljs-keyword">throw</span> e;
      }
      <span class="hljs-keyword">return</span> results;
    }
  }</pre></div>
            
          
            
            <p>Sends a single IP object to a port</p>

            
              <div class='highlight'><pre>  sendIP(port, packet) {
    <span class="hljs-keyword">var</span> ip;
    <span class="hljs-keyword">if</span> (!IP.isIP(packet)) {
      ip = <span class="hljs-keyword">new</span> IP(<span class="hljs-string">'data'</span>, packet);
    } <span class="hljs-keyword">else</span> {
      ip = packet;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scope !== <span class="hljs-literal">null</span> &amp;&amp; ip.scope === <span class="hljs-literal">null</span>) {
      ip.scope = <span class="hljs-keyword">this</span>.scope;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nodeInstance.outPorts[port].isAddressable() &amp;&amp; ip.index === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Sending packets to addressable ports requires specifying index'</span>);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nodeInstance.isOrdered()) {
      <span class="hljs-keyword">this</span>.nodeInstance.addToResult(<span class="hljs-keyword">this</span>.result, port, ip);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.nodeInstance.outPorts[port].options.scoped) {
      ip.scope = <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nodeInstance.outPorts[port].sendIP(ip);
  }</pre></div>
            
          
            
            <p>Sends packets for each port as a key in the map
or sends Error or a list of Errors if passed such</p>

            
              <div class='highlight'><pre>  send(outputMap) {
    <span class="hljs-keyword">var</span> componentPorts, i, len1, mapIsInPorts, packet, port, ref, results;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isError(outputMap)) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.error(outputMap);
    }
    componentPorts = [];
    mapIsInPorts = <span class="hljs-literal">false</span>;
    ref = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.ports.ports);
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len1 = ref.length; i &lt; len1; i++) {
      port = ref[i];
      <span class="hljs-keyword">if</span> (port !== <span class="hljs-string">'error'</span> &amp;&amp; port !== <span class="hljs-string">'ports'</span> &amp;&amp; port !== <span class="hljs-string">'_callbacks'</span>) {
        componentPorts.push(port);
      }
      <span class="hljs-keyword">if</span> (!mapIsInPorts &amp;&amp; (outputMap != <span class="hljs-literal">null</span>) &amp;&amp; <span class="hljs-keyword">typeof</span> outputMap === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-built_in">Object</span>.keys(outputMap).indexOf(port) !== <span class="hljs-number">-1</span>) {
        mapIsInPorts = <span class="hljs-literal">true</span>;
      }
    }
    <span class="hljs-keyword">if</span> (componentPorts.length === <span class="hljs-number">1</span> &amp;&amp; !mapIsInPorts) {
      <span class="hljs-keyword">this</span>.sendIP(componentPorts[<span class="hljs-number">0</span>], outputMap);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (componentPorts.length &gt; <span class="hljs-number">1</span> &amp;&amp; !mapIsInPorts) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Port must be specified for sending output'</span>);
    }
    results = [];
    <span class="hljs-keyword">for</span> (port <span class="hljs-keyword">in</span> outputMap) {
      packet = outputMap[port];
      results.push(<span class="hljs-keyword">this</span>.sendIP(port, packet));
    }
    <span class="hljs-keyword">return</span> results;
  }</pre></div>
            
          
            
            <p>Sends the argument via <code>send()</code> and marks activation as <code>done()</code></p>

            
              <div class='highlight'><pre>  sendDone(outputMap) {
    <span class="hljs-keyword">this</span>.send(outputMap);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.done();
  }</pre></div>
            
          
            
            <p>Makes a map-style component pass a result value to <code>out</code>
keeping all IP metadata received from <code>in</code>,
or modifying it if <code>options</code> is provided</p>

            
              <div class='highlight'><pre>  pass(data, options = {}) {
    <span class="hljs-keyword">var</span> key, val;
    <span class="hljs-keyword">if</span> (!(<span class="hljs-string">'out'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.ports)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'output.pass() requires port "out" to be present'</span>);
    }
    <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> options) {
      val = options[key];
      <span class="hljs-keyword">this</span>.ip[key] = val;
    }
    <span class="hljs-keyword">this</span>.ip.data = data;
    <span class="hljs-keyword">this</span>.sendIP(<span class="hljs-string">'out'</span>, <span class="hljs-keyword">this</span>.ip);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.done();
  }</pre></div>
            
          
            
            <p>Finishes process activation gracefully</p>

            
              <div class='highlight'><pre>  done(error) {
    <span class="hljs-keyword">var</span> buf, context, contexts, ctx, ip, isLast, nodeContext, port, ref;
    <span class="hljs-keyword">this</span>.result.__resolved = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.nodeInstance.activate(<span class="hljs-keyword">this</span>.context);
    <span class="hljs-keyword">if</span> (error) {
      <span class="hljs-keyword">this</span>.error(error);
    }
    isLast = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">var</span> len, load, pos, resultsOnly;</pre></div>
            
          
            
            <p>We only care about real output sets with processing data</p>

            
              <div class='highlight'><pre>      resultsOnly = <span class="hljs-keyword">this</span>.nodeInstance.outputQ.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">q</span>) </span>{
        <span class="hljs-keyword">if</span> (!q.__resolved) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(q).length === <span class="hljs-number">2</span> &amp;&amp; q.__bracketClosingAfter) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      });
      pos = resultsOnly.indexOf(<span class="hljs-keyword">this</span>.result);
      len = resultsOnly.length;
      load = <span class="hljs-keyword">this</span>.nodeInstance.load;
      <span class="hljs-keyword">if</span> (pos === len - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">if</span> (pos === <span class="hljs-number">-1</span> &amp;&amp; load === len + <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span> &amp;&amp; load === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    };
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nodeInstance.isOrdered() &amp;&amp; isLast()) {
      ref = <span class="hljs-keyword">this</span>.nodeInstance.bracketContext.in;</pre></div>
            
          
            
            <p>We’re doing bracket forwarding. See if there are
dangling closeBrackets in buffer since we’re the
last running process function.</p>

            
              <div class='highlight'><pre>      <span class="hljs-keyword">for</span> (port <span class="hljs-keyword">in</span> ref) {
        contexts = ref[port];
        <span class="hljs-keyword">if</span> (!contexts[<span class="hljs-keyword">this</span>.scope]) {
          <span class="hljs-keyword">continue</span>;
        }
        nodeContext = contexts[<span class="hljs-keyword">this</span>.scope];
        <span class="hljs-keyword">if</span> (!nodeContext.length) {
          <span class="hljs-keyword">continue</span>;
        }
        context = nodeContext[nodeContext.length - <span class="hljs-number">1</span>];
        buf = <span class="hljs-keyword">this</span>.nodeInstance.inPorts[context.source].getBuffer(context.ip.scope, context.ip.index);
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">if</span> (!buf.length) {
            <span class="hljs-keyword">break</span>;
          }
          <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>].type !== <span class="hljs-string">'closeBracket'</span>) {
            <span class="hljs-keyword">break</span>;
          }
          ip = <span class="hljs-keyword">this</span>.nodeInstance.inPorts[context.source].get(context.ip.scope, context.ip.index);
          ctx = nodeContext.pop();
          ctx.closeIp = ip;
          <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.result.__bracketClosingAfter) {
            <span class="hljs-keyword">this</span>.result.__bracketClosingAfter = [];
          }
          <span class="hljs-keyword">this</span>.result.__bracketClosingAfter.push(ctx);
        }
      }
    }
    debug(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeInstance.nodeId}</span> finished processing <span class="hljs-subst">${<span class="hljs-keyword">this</span>.nodeInstance.load}</span>`</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nodeInstance.deactivate(<span class="hljs-keyword">this</span>.context);
  }

};</pre></div>
            
          
          <p><small>This page contains documentation generated automatically from NoFlo's <a href="https://github.com/noflo/noflo/blob/master/src/lib/Component.coffee">Component.coffee</a> file.</small></p>
        </div>
      </div>
    </div>
  </div>
